import { VTKLayout, imageCache, toolManager } from 'vtk-viewport';
import {
  wwwcTool,
  panTool,
  zoomTool,
  mouseWheelScrollTool,
} from 'someToolPlace'; // I'd kinda rather these aren't in this library. vtkjs-tools?

const containerElement = document.getElementById('myCanvas');
const layout = new VTKLayout(containerElement, 'monitor1');

const ctUID = imageCache.makeAndCacheVolume(ctImageIds);
const ptUID = imageCache.makeAndCacheVolume(ptImageIds);

// Note post meeting: Helper to make volume without imageIds.

function setCTWWWC(volumeActor) {
  // Something
}

function setPTColorMapTransferFunction(volumeActor) {
  // Sets the PT actor with a color map
}

function setPTInvertedTransferFunction(volumeActor) {
  // Sets the PT actor so that it renders inverted.
}

const SCENE_IDS = {
  CT: 'ctScene',
  PT: 'ptScene',
  FUSION: 'fusionScene',
};

const VIEWPORT_IDS = {
  CT: {
    AXIAL: 'ctAxial',
    SAGITTAL: 'ctSagittal',
    CORONAL: 'ctCoronal',
  },
  PT: {
    AXIAL: 'ptAxial',
    SAGITTAL: 'ptSagittal',
    CORONAL: 'ptCoronal',
  },
  FUSION: {
    AXIAL: 'fusionAxial',
    SAGITTAL: 'fusionSagittal',
    CORONAL: 'fusionCoronal',
  },
};

// This will generate all the renderers and initialise them (cameras and such).
// It will not render anything though, untill we call layout.render();
// 3x3 grid with:
// CT: Axial, Sagittal, Coronal
// PT: Axial, Sagittal, Coronal
// Fusion: Axial, Sagittal, Coronal
layout.setLayout([
  // CT
  {
    sceneUID: SCENE_IDS.CT,
    viewportUID: VIEWPORT_IDS.CT.AXIAL,
    type: 'orthogonal',
    position: [0, 1 / 3, 0, 1 / 3],
  },
  {
    sceneUID: SCENE_IDS.CT,
    viewportUID: VIEWPORT_IDS.CT.SAGITTAL,
    type: 'orthogonal',
    position: [1 / 3, 2 / 3, 0, 1 / 3],
  },
  {
    sceneUID: SCENE_IDS.CT,
    viewportUID: VIEWPORT_IDS.CT.CORONAL,
    type: 'orthogonal',
    position: [2 / 3, 1, 0, 1 / 3],
  },
  // PT
  {
    sceneUID: SCENE_IDS.PT,
    viewportUID: VIEWPORT_IDS.PT.AXIAL,
    type: 'orthogonal',
    position: [0, 1 / 3, 1 / 3, 2 / 3],
  },
  {
    sceneUID: SCENE_IDS.PT,
    viewportUID: VIEWPORT_IDS.PT.SAGITTAL,
    type: 'orthogonal',
    position: [1 / 3, 2 / 3, 1 / 3, 2 / 3],
  },
  {
    sceneUID: SCENE_IDS.PT,
    viewportUID: VIEWPORT_IDS.PT.CORONAL,
    type: 'orthogonal',
    position: [2 / 3, 1, 1 / 3, 2 / 3],
  },
  // FUSION
  {
    sceneUID: SCENE_IDS.FUSION,
    viewportUID: VIEWPORT_IDS.FUSION.AXIAL,
    type: 'orthogonal',
    position: [0, 1 / 3, 2 / 3, 1],
  },
  {
    sceneUID: SCENE_IDS.FUSION,
    viewportUID: VIEWPORT_IDS.FUSION.SAGITTAL,
    type: 'orthogonal',
    position: [1 / 3, 2 / 3, 2 / 3, 1],
  },
  {
    sceneUID: SCENE_IDS.FUSION,
    viewportUID: VIEWPORT_IDS.FUSION.CORONAL,
    type: 'orthogonal',
    position: [2 / 3, 1, 2 / 3, 1],
  },
]);

// Get scenes
const ctScene = layout.getScene(SCENE_IDS.CT);
const ptScene = layout.getScene(SCENE_IDS.PT);
const fusionScene = layout.getScene(SCENE_IDS.FUSION);

// Add the data to the scenes, and apply the correct transfer functions.
ctScene.setVolumes([{ volumeUID: ctUID, callback: setCTWWWC }]);
ptScene.setVolumes([
  { volumeUID: ptUID, callback: setPTInvertedTransferFunction },
]);
fusionScene.setVolumes([
  { volumeUID: ctUID, callback: setCTWWWC },
  { volumeUID: ptUID, callback: setPTColorMapTransferFunction },
]);

// Start fetching volumes now - refresh when appropriate
function throttledRenderSceneCT() {
  ctScene.render();
  fusionScene.render();
}

function throttledRenderScenePT() {
  ptScene.render();
  fusionScene.render();
}

imageCache.loadVolume(ctUID, throttledRenderSceneCT);
imageCache.loadVolume(ptUID, throttledRenderScenePT);

//W/L across CT and Fusion
//threshold across PET and Fusion
//Pan / Zoom / scroll across CT/PET/Fusion in same orientation

// Add tools to the tool manager. When a tool group adds these we apply them.
// This can be once for the app and reused as needed (like cornerstone-tools)
toolManager.addTool(wwwcTool, 'wwwc');
toolManager.addTool(panTool, 'pan');
toolManager.addTool(zoomTool, 'zoom');
toolManager.addTool(mouseWheelScrollTool, 'mouseWheelScroll');

// Define tool groups - These could be dynamically generated by the app, or hardcoded somewhere.

// tools per viewport:
// CT A: WL: (sync: CT, FUSION), pan, zoom, scroll (sync: PT.A, FUSION.A ),
// CT S: WL: (sync: CT, FUSION), pan, zoom, scroll (sync: PT.S, FUSION.S ),
// CT C: WL: (sync: CT, FUSION), pan, zoom, scroll (sync: PT.C, FUSION.C ),
// PT A: WL: (sync: PT, FUSION), pan, zoom, scroll (sync: CT.A, FUSION.A ),
// PT S: WL: (sync: PT, FUSION), pan, zoom, scroll (sync: CT.S, FUSION.S ),
// PT C: WL: (sync: PT, FUSION), pan, zoom, scroll (sync: CT.C, FUSION.C ),
// FS A: pan, zoom, scroll (sync: CT.A, PT.A ),
// FS S: pan, zoom, scroll (sync: CT.S, PT.S ),
// FS C: pan, zoom, scroll (sync: CT.C, PT.C ),

// toolGroups:
// -- axialManipulation
// -- sagittalManipulation
// -- coronalManipulation
// -- CT WL
// -- PT WL

function makeManipulationGroup(UID, synchronizedViewportIds) {
  return {
    UID,
    tools: [
      {
        toolName: 'pan',
        button: toolManager.buttons.MIDDLE,
        synchronization: [...synchronizedViewportIds],
        options: {},
      },
      {
        toolName: 'zoom',
        button: toolManager.buttons.RIGHT,
        synchronization: [...synchronizedViewportIds],
        options: {},
      },
      {
        toolName: 'mouseWheelScroll',
        button: toolManager.buttons.MOUSE_SCROLL,
        synchronization: [...synchronizedViewportIds],
        options: {},
      },
    ],
  };
}

const axialManipulationToolGroup = makeManipulationGroup('axialManipulation', [
  VIEWPORT_IDS.CT.AXIAL,
  VIEWPORT_IDS.PT.AXIAL,
  VIEWPORT_IDS.FUSION.AXIAL,
]);

const sagittalManipulationToolGroup = makeManipulationGroup(
  'sagittalManipulation',
  [
    VIEWPORT_IDS.CT.SAGITTAL,
    VIEWPORT_IDS.PT.SAGITTAL,
    VIEWPORT_IDS.FUSION.SAGITTAL,
  ]
);
const coronalManipulationToolGroup = makeManipulationGroup(
  'coronalManipulation',
  [
    VIEWPORT_IDS.CT.CORONAL,
    VIEWPORT_IDS.PT.CORONAL,
    VIEWPORT_IDS.FUSION.CORONAL,
  ]
);

const ctWindowLevelGroup = {
  UID: 'ctWindowLevel',
  tools: [
    {
      toolName: 'wwwc',
      button: toolManager.buttons.LEFT,
      synchronization: [
        VIEWPORT_IDS.CT.AXIAL,
        VIEWPORT_IDS.CT.SAGITTAL,
        VIEWPORT_IDS.CT.CORONAL,
        VIEWPORT_IDS.FUSION.AXIAL,
        VIEWPORT_IDS.FUSION.SAGITTAL,
        VIEWPORT_IDS.FUSION.CORONAL,
      ],
      options: {
        volumeUID: ctUID, // Volume to manipulate window level of
      },
    },
  ],
};

const ptWindowLevelGroup = {
  UID: 'ptWindowLevel',
  tools: [
    {
      toolName: 'wwwc',
      button: toolManager.buttons.LEFT,
      synchronization: [
        VIEWPORT_IDS.PT.AXIAL,
        VIEWPORT_IDS.PT.SAGITTAL,
        VIEWPORT_IDS.PT.CORONAL,
        VIEWPORT_IDS.FUSION.AXIAL,
        VIEWPORT_IDS.FUSION.SAGITTAL,
        VIEWPORT_IDS.FUSION.CORONAL,
      ],
      options: {
        volumeUID: ptUID, // Volume to manipulate window level of
        isPet: true,
      },
    },
  ],
};

// Add all the tool groups to the layout
layout.addToolGroup(axialManipulationToolGroup);
layout.addToolGroup(sagittalManipulationToolGroup);
layout.addToolGroup(coronalManipulationToolGroup);
layout.addToolGroup(ctWindowLevelGroup);
layout.addToolGroup(ptWindowLevelGroup);

// Add multiple tool groups for viewports. The event dispatcher will use fall through,
// So if the first doesn't have a handler for that event (e.g. left mouse down),
// It will fall to the next toolgroup.

// Set the tool groups for each viewport.
ctScene
  .getViewport(VIEWPORT_IDS.CT.AXIAL)
  .setToolGroups(['ctWindowLevel', 'axialManipulation']);
ctScene
  .getViewport(VIEWPORT_IDS.CT.SAGITTAL)
  .setToolGroups(['ctWindowLevel', 'sagittalManipulation']);
ctScene
  .getViewport(VIEWPORT_IDS.CT.CORONAL)
  .setToolGroups(['ctWindowLevel', 'coronalManipulation']);

ptScene
  .getViewport(VIEWPORT_IDS.PT.AXIAL)
  .setToolGroups(['ptWindowLevel', 'axialManipulation']);
ptScene
  .getViewport(VIEWPORT_IDS.PT.SAGITTAL)
  .setToolGroups(['ptWindowLevel', 'sagittalManipulation']);
ptScene
  .getViewport(VIEWPORT_IDS.PT.CORONAL)
  .setToolGroups(['ptWindowLevel', 'coronalManipulation']);

fusionScene
  .getViewport(VIEWPORT_IDS.FUSION.AXIAL)
  .setToolGroups(['axialManipulation']);
fusionScene
  .getViewport(VIEWPORT_IDS.FUSION.SAGITTAL)
  .setToolGroups(['sagittalManipulation']);
fusionScene
  .getViewport(VIEWPORT_IDS.FUSION.CORONAL)
  .setToolGroups(['coronalManipulation']);
