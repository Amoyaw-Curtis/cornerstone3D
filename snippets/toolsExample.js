import { VTKLayout, imageCache, toolManager } from 'vtk-viewport';
import {
  wwwcTool,
  panTool,
  zoomTool,
  mouseWheelScrollTool,
  rotate3DTool,
} from 'someToolPlace'; // I'd kinda rather these aren't in this library. vtkjs-tools?

const containerElement = document.getElementById('myCanvas');
const layout = new VTKLayout(containerElement, 'monitor1');

const ctUID = imageCache.makeAndCacheVolume(ctImageIds);

function setCTWWWC(volumeActor) {
  // Something
}

const axialViewportID = 'axial';
const sagittalViewportID = 'sagittal';
const coronalViewportID = 'coronal';
const volumeViewportID = 'volume';
const fourUpSceneID = '4Up';

// This will generate all the renderers and initialise them (cameras and such).
// It will not render anything though, untill we call layout.render();
layout.setLayout([
  {
    sceneUID: fourUpSceneID,
    viewportUID: axialViewportID,
    type: 'orthogonal',
    position: [0, 0.5, 0, 0.5],
  },
  {
    sceneUID: fourUpSceneID,
    viewportUID: sagittalViewportID,
    type: 'orthogonal',
    position: [0.5, 1, 0, 0.5],
  },
  {
    sceneUID: fourUpSceneID,
    viewportUID: coronalViewportID,
    type: 'orthogonal',
    position: [0, 0.5, 0.5, 1],
  },
  {
    sceneUID: fourUpSceneID,
    viewportUID: volumeViewportID,
    type: 'perspective',
    position: [0.5, 1, 0.5, 1],
  },
]);

const fourUpScene = layout.getScene(fourUpSceneID);

// Start fetching volumes now
function throttledRenderScene() {
  fourUpScene.render(); // Throttled render on image load
}

imageCache.loadVolume(ctUID, throttledRenderScene);
imageCache.loadVolume(ptUID, throttledRenderScene);

fourUpScene.setVolumes([{ volumeUID: ctUID, callback: setCTWWWC }]);

// Add tools to the tool manager. When a tool group adds these we apply them.
// This can be once for the app and reused as needed (like cornerstone-tools)
toolManager.addTool(wwwcTool, 'wwwc');
toolManager.addTool(panTool, 'pan');
toolManager.addTool(zoomTool, 'zoom');
toolManager.addTool(mouseWheelScrollTool, 'mouseWheelScroll');
toolManager.addTool(rotate3DTool, 'rotate3D');

// Define tool groups - These could be dynamically generated by the app, or hardcoded somewhere.

// Synchronization notes:
// If we wanted to synchronize the same tools across different viewports, we would put them in different tool groups.
// The worst case scenario is you make a toolgroup per viewport, but most cases will be simpler.

const mprManipultationToolGroup = {
  UID: 'mprManipultation',
  tools: [
    {
      toolName: 'wwwc',
      button: toolManager.buttons.LEFT,
      options: {},
    },
    {
      toolName: 'pan',
      button: toolManager.buttons.MIDDLE,
      options: {},
    },
    {
      toolName: 'zoom',
      button: toolManager.buttons.RIGHT,
      options: {},
    },
    {
      toolName: 'mouseWheelScroll',
      button: toolManager.buttons.MOUSE_SCROLL,
      options: {},
    },
  ],
};

const rotate3DToolGroup = {
  UID: 'rotate3D',
  tools: [
    {
      toolName: 'rotate3D',
      button: toolManager.buttons.LEFT,
      options: {},
    },
  ],
};

layout.addToolGroup(mprManipultationToolGroup);
layout.addToolGroup(rotate3DToolGroup);

const updateVoiSynchronizer = (sourceViewportUID, viewportUIDs, eventData) => {
  // Do something
  const layoutApi = VTKLayout.getLayoutByUID('monitor1');

  // From sourceViewportUID -> getVolume

  // get Voi from this volume

  // For each viewport UID
  // -- If same scene do nothing.
  // -- If other scene:
  // -- -- Find actor for same volume UID.
  // -- -- Apply same voi to these volumes.

  // Call render on all scenes touched.
};

const ctWindowLevelSyncGroup = {
  eventName: 'voiChange',
  synchronizer: updateVoiSynchronizer,
  UID: 'ctWindowLevelSyncGroup',
};

// Set the tool groups for each viewport.
const axialViewport = fourUpScene.getViewport(axialViewportID);
const sagittalViewport = fourUpScene.getViewport(sagittalViewportID);
const coronalViewport = fourUpScene.getViewport(coronalViewportID);
const volumeRenderViewport = fourUpScene
  .getViewport(volumeViewportID)

  [
    // Set toolgroups for our MPR reformatted planes.
    (axialViewport, sagittalViewport, coronalViewport)
  ].forEach(viewport => {
    viewport.setToolGroup('mprManipultation');
    viewport.setSyncGroups(['ctWindowLevelSyncGroup']);
  });

// Set toolgroup for our 3D view.
volumeRenderViewport.setToolGroup('rotate3D');

// Now when the master tool recieves events on the viewport,
// The toolgroup of that viewport is checked to see how we should process these events.
